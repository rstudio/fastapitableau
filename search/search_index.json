{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#fastapi-tableau","title":"FastAPI Tableau","text":"<p>Documentation: https://rstudio.github.io/fastapitableau</p> <p>Source Code: https://github.com/rstudio/fastapitableau</p> <p>FastAPI Tableau lets you call external Python code from Tableau workbooks via Tableau Analytics Extensions. To do this, you write an API using FastAPI, with some minor modifications. If you aren't already familiar with FastAPI, we suggest you start with their tutorial. </p> <p>The main change required for your API to be callable from Tableau is to replace the <code>FastAPI</code> app class with <code>FastAPITableau</code>.</p> <pre><code># Base FastAPI\nfrom fastapi import FastAPI\napp = FastAPI()\n\n# FastAPI Tableau\nfrom fastapitableau import FastAPITableau\napp = FastAPITableau()\n</code></pre> <p>When you do this, FastAPI Tableau will reroute and transform requests from Tableau, which arrive at the <code>/evaluate</code> endpoint, to the endpoints you define in your app. It will also show documentation for Tableau users at the root of your API, with copy-and-paste code samples for Tableau calls.</p> <p>Before you write an extension with FastAPI Tableau, you should be familiar with FastAPI. The Tutorial is a great place to start. You should also take a look at the limitations of FastAPI Tableau extensions, described below.</p>"},{"location":"#a-simple-fastapi-tableau-extension","title":"A simple FastAPI Tableau extension","text":"<pre><code>from typing import List\n\nfrom fastapitableau import FastAPITableau\n\napp = FastAPITableau(\n    title=\"Simple Example\",\n    description=\"A *simple* example FastAPITableau app.\",\n    version=\"0.1.0\",\n)\n\n\n@app.post(\"/capitalize\")\ndef capitalize(text: List[str]) -&gt; List[str]:\n    capitalized = [t.upper() for t in text]\n    return capitalized\n</code></pre> <p>If you put this code in a file named <code>simple.py</code> in your terminal's working directory, you can serve it locally using Uvicorn, by invoking <code>uvicorn simple:app --reload</code>.</p>"},{"location":"#fastapi-tableau-extensions-support-a-limited-set-of-data-model-features","title":"FastAPI Tableau extensions support a limited set of data model features","text":"<p>FastAPI Tableau extensions have a few constraints compared to standard FastAPI apps. Some of these are due to the ways that Tableau sends data. We'll describe known limitations here, and how to work within them.</p> <p>All parameters that receive data from Tableau must be list fields. Tableau sends its data in JSON lists in the request body, which FastAPI converts to equivalent Python types. Compatible types are <code>List[str]</code>, <code>List[float]</code>, <code>List[int]</code>, and <code>List[bool]</code>. You can define these parameters as arguments to an endpoint function, or as fields in a Pydantic model.</p> <p>Your endpoints must also return data in a compatible list types, and the data returned must be the same length as the inputs received. This requirement is not enforced by FastAPI Tableau, but Tableau maps the data sent back by an extension into a table column.</p> <p>You can use query parameters in your functions by declaring singular (non-<code>List</code>) arguments. FastAPI assumes that any <code>bool</code>, <code>float</code>, <code>int</code>, or <code>str</code> variables are query parameters. You can use these in the <code>script</code> argument when calling the API from Tableau.</p> <p>Putting this all together, you can have as many list and singular parameters as you want, declared in the function definition. List parameters will come from Tableau data objects, and singular parameters can be set in the Tableau calculation.</p> <p>For example, if you wanted an endpoint to multiply data by a user-provided number, you could define it like this:</p> <pre><code>@app.post(\"/multiply\")\ndef multiply(numbers: List[float], multiplier: float) -&gt; List[float]:\n    result = [i * multiplier for i in numbers]\n    return result\n</code></pre> <p>FastAPI Tableau will automatically generate Tableau usage examples for your endpoints, using your type annotations, so providing complete type annotations will make it easier to use your APIs from Tableau.</p>"},{"location":"#additional-descriptive-metadata-for-endpoints","title":"Additional descriptive metadata for endpoints","text":"<p>You can add additional metadata to endpoints as you would with a regular FastAPI app, in the endpoint decorator and the docstring.</p> <pre><code>@app.post(\n    \"/paste\",\n    summary=\"Parallel concatenation on two lists of strings\",\n    response_description=\"A list of concatenated strings\",\n)\ndef paste(first: List[str], second: List[str]) -&gt; List[str]:\n    \"\"\"\n    Given two lists of strings, iterate over them, concatenating parallel items.\n\n    - **first**: the first list of strings\n    - **second**: the second list of strings\n    \"\"\"\n    result = [a + \" \" + b for a, b in zip(first, second)]\n    return result\n</code></pre> <p>This metadata will appear in the documentation for Tableau users.</p>"},{"location":"#deploying-extensions-to-rstudio-connect","title":"Deploying extensions to RStudio Connect","text":"<p>You can deploy FastAPI Tableau extensions to RStudio Connect with <code>rsconnect-python</code>. Detailed documentation can be found over there.</p> <pre><code>rsconnect deploy fastapi \\\n    --server https://connect.example.org:3939 \\\n    --api-key my-api-key \\\n    my_api_directory/\n</code></pre> <p>rsconnect-python assumes that your API is the only Python in its directory. For best results, specify your API's dependencies in a <code>requirements.txt</code> file in the same directory. See more information here.</p>"},{"location":"#using-self-signed-certificates","title":"Using self-signed certificates","text":"<p>When using self-signed certificates with FastAPI Tableau, you must make Python aware of the path to the certificate.</p> <p>Set the <code>REQUESTS_CA_BUNDLE</code> environment variable to the path to your certificate file. This variable is used by the underlying Requests library, and is documented here.</p> <p>In RStudio Connect, set the environment variable in the Vars tab of the Content Settings Panel. Note that applications running on RStudio Connect cannot access the <code>/etc</code> directory, so the certificate must be in a different location, such as <code>/opt/python</code>.</p>"},{"location":"#calling-an-extension-endpoint-in-tableau","title":"Calling an extension endpoint in Tableau","text":"<p>You can copy and paste the usage example (the <code>SCRIPT_*</code> command) into a calculated field in Tableau (it generates the correct URL), and replace the argument placeholders with actual values from the Tableau workbook.</p>"},{"location":"#working-with-tableau-data","title":"Working with Tableau data","text":"<p>We've found that a few practices in Tableau ensure that the data you pass to a Tableau extension is sent correctly.</p> <ul> <li>You must turn off \"Aggregate Measures\" under the \"Analysis\" menu for Tableau to pass the correct values to the extension. If this setting is on, Tableau will send aggregated data to the extension, which may cause inaccuracies in computations.</li> <li>With this value off, calculated fields don't allow you to pass raw values directly to an extension. Those values must be wrapped in an aggregating function. Since we've turned \"Aggregate Measures\" off, these functions won't actually aggregate the data. We've had success using <code>ATTR([VALUE_NAME])</code>.</li> </ul>"},{"location":"#debug-logging","title":"Debug logging","text":"<p>To enable verbose debug logging, set the environment variable <code>FASTAPITABLEAU_LOG_LEVEL</code> to <code>DEBUG</code>.</p>"}]}